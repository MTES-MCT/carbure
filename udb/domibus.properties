# ---------------------------------- Cluster -----------------------------------

#Specifies if Domibus should run in cluster mode. This affects for instance whether the Quartz jobs are clustered.
#domibus.deployment.clustered=false

#In cluster mode, specifies if the database synchronization mechanism should be used when initializing the Quartz scheduler
#domibus.scheduler.bootstrap.synchronized=true

# ---------------------------------- GUI -------------------------

# The title shown in the Tab of Admin Console (default value: "Domibus")
#domibus.UI.title.name=Domibus

#support team name
#domibus.ui.support.team.name=EDELIVERY Support Team

#support team email
#domibus.ui.support.team.email=CEF-EDELIVERY-SUPPORT@ec.europa.eu

#Max rows for CSV export
#domibus.ui.csv.rows.max=10000

# how many minutes after message's received date the Resend button will become enabled for messages having SEND_ENQUEUED status
#domibus.ui.resend.action.enabled.received.minutes=5

#The limit when calculating the number of message logs(disabled when 0)
#domibus.ui.pages.messageLogs.countLimit=50000

#The initial/default interval (in hours) for filtering messages
#domibus.ui.pages.messageLogs.interval.default=24

#Used to secure the session of admin console; set to true only in conjunction with https protocol
#domibus.ui.session.secure=false

#Used to set the the session timeout of admin console ( in minutes )
#domibus.ui.session.timeout=30

#Used to set the SameSite attribute of cookies (session and all others) used by the admin console. Possible values are: Strict, None, Lax
#domibus.ui.session.sameSite=Strict

#Used to which JVM to route to for session affinity ensuring that the value of the session cookie is formatted as
#'sessionId + "." + jvmRoute'; the jvmRoute can be the name of an environment variable or a Java system property
#(default empty, i.e. no session affinity)
#domibus.ui.session.jvmroute=

# ---------------------------------- Keystore/Truststore -----------------------

#The initial location of the keystore; used only the first time domibus starts and persisted in the DB to be used from there on
domibus.security.keystore.location=${domibus.config.location}/keystores/gateway_keystore.jks

#The type of the used keystore
domibus.security.keystore.type=jks

#The password used to load the keystore
domibus.security.keystore.password=$DOMIBUS_SECURITY_KEYSTORE_PASSWORD

#Private key
#The alias from the keystore of the private key
domibus.security.key.private.alias=$DOMIBUS_SECURITY_KEY_PRIVATE_ALIAS

#The private key password
domibus.security.key.private.password=$DOMIBUS_SECURITY_KEY_PRIVATE_PASSWORD

#Truststore
#The initial location of the truststore; used only the first time domibus starts and persisted in the DB to be used from there on
domibus.security.truststore.location=${domibus.config.location}/keystores/gateway_truststore.jks

#Type of the used truststore
domibus.security.truststore.type=jks

#The password used to load the trustStore
domibus.security.truststore.password=$DOMIBUS_SECURITY_TRUST_PASSWORD

# ---------------------------------- Database ----------------------------------

#Database server name
domibus.database.serverName=$DOMIBUS_DATABASE_SERVERNAME

#Database port
domibus.database.port=$DOMIBUS_DATABASE_PORT

#General schema. Mandatory only if Domibus is configured in multi-tenancy mode.
#domibus.database.general.schema=general_schema

#Domibus schema. If Domibus is configured in multi-tenancy mode this property is used to define the schema for the default domain.
#Please comment this property, if Domibus is configured in single-tenancy mode with Oracle database.
domibus.database.schema=$DOMIBUS_DATABASE_SCHEMA

#Non-XA Datasource
#MySQL
#Connector/J 8.0.x
domibus.datasource.driverClassName=com.mysql.cj.jdbc.Driver

domibus.datasource.url=jdbc:mysql://${domibus.database.serverName}:${domibus.database.port}/${domibus.database.schema}?useSSL=false&useLegacyDatetimeCode=false&serverTimezone=UTC&allowPublicKeyRetrieval=true

#Oracle
#domibus.datasource.driverClassName=oracle.jdbc.OracleDriver
#domibus.datasource.url=jdbc:oracle:thin:@${domibus.database.serverName}:${domibus.database.port}/XE

domibus.datasource.user=$DOMIBUS_DATASOURCE_USER
domibus.datasource.password=$DOMIBUS_DATASOURCE_PASSWORD

#HikariCP specific
#Controls the maximum lifetime of a connection in the pool (in seconds)
#domibus.datasource.maxLifetime=1800

#Controls the maximum amount of time (in seconds) that a client will wait for a connection from the pool
#domibus.datasource.connectionTimeout=30

#Controls the maximum amount of time (in seconds) that a connection is allowed to sit idle in the pool
#domibus.datasource.idleTimeout=600

#Controls the maximum size that the pool is allowed to reach, including both idle and in-use connections
#domibus.datasource.maxPoolSize=10

#Controls the minimum number of idle connections that HikariCP tries to maintain in the pool
#domibus.datasource.minimumIdle=10

#Represents a user-defined name for the connection pool and appears mainly in logging and JMX management consoles; empty to auto-generate
#domibus.datasource.poolName=

# ---------------------------------- EntityManagerFactory ----------------------

#Packages to be scanned(comma separated)
#domibus.entityManagerFactory.packagesToScan=eu.domibus

#Number of rows fetched when there is more than a one row result on select statements (use only for Oracle, for MySQL JDBC driver caches the entire result set up front, so no need to set the fetch size)
#domibus.entityManagerFactory.jpaProperty.hibernate.jdbc.fetch_size=50

#MySQL
#Connector/J 8.0.x
domibus.entityManagerFactory.jpaProperty.hibernate.connection.driver_class=com.mysql.cj.jdbc.Driver

domibus.entityManagerFactory.jpaProperty.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect
domibus.entityManagerFactory.jpaProperty.hibernate.id.new_generator_mappings=false

#Oracle
#domibus.entityManagerFactory.jpaProperty.hibernate.connection.driver_class=oracle.jdbc.driver.OracleDriver
#domibus.entityManagerFactory.jpaProperty.hibernate.dialect=org.hibernate.dialect.Oracle10gDialect

#domibus.entityManagerFactory.jpaProperty.hibernate.format_sql=true

# ---------------------------------- Security ----------------------------------

#Domibus encrypts the configured passwords if activated
#domibus.password.encryption.active=false

#Enable this property if the password encryption is activated. Add the list of configured passwords to be encrypted.
#domibus.password.encryption.properties=domibus.security.keystore.password,domibus.security.key.private.password,domibus.security.truststore.password,domibus.datasource.password,domibus.proxy.password,domibus.alert.sender.smtp.password

#The location where the encrypted key is stored
#domibus.password.encryption.key.location=${domibus.config.location}/internal/encrypt

#To activate security set this to false
#domibus.auth.unsecureLoginAllowed=true

#Number of console login attempt before the user is deactivated (default 5)
#domibus.console.login.maximum.attempt=5

#Time in seconds for a suspended user to be reactivated. (1 hour per default if property is not set, if 0 the user will not be reactivated)
#domibus.console.login.suspension.time=3600

#Cron job that determines the interval at which the system checks for account to be reactivated.
#domibus.account.unlock.cron=0 0/1 * * * ?

#When a certificate is about to expires the system will log a warning. The warning will appear as from the expiration date - the offset in days.
#domibus.certificate.revocation.offset=15

#Cron expression that specifies the frequency of the certificate revocation check.
#domibus.certificate.check.cron=0 0 0/1 * * ?

#The list of protocols to be excluded from CRL list (possible values: http, https, ftp, file, ldap, etc)
#domibus.certificate.crl.excludedProtocols=

#Configure http timeout (http.connection.timeout, http.socket.timeout, http.connection-manager.timeout) in seconds. Defaults to 10 seconds.
#domibus.certificate.crl.http.timeout=10

# ---------------------------------- Extensions ----------------------------------

#Name of the authentication extension used to verify the chain trust. Default is CXF
#domibus.extension.iam.authentication.identifier=DEFAULT_AUTHENTICATION_SPI
#Name of the authorization extension used to check incoming message authorization. Default is truststore check.
#domibus.extension.iam.authorization.identifier=DEFAULT_AUTHORIZATION_SPI

# ---------------------------------- Plugin Security ----------------------------------

#Number of plugin users login attempts before the user is deactivated (default 5)
#domibus.plugin.login.maximum.attempt=5

#Time in seconds for a suspended plugin user to be reactivated. (1 hour per default if property is not set, if 0 the user will not be reactivated)
#domibus.plugin.login.suspension.time=3600

#Cron job that determines the interval at which the system checks for plugin account to be reactivated.
#domibus.plugin.account.unlock.cron=0 0/1 * * * ?

# ---------------------------------- Password Policy -----------------------------------

#Password minimum complexity rules (empty to disable password complexity enforcement)
#domibus.passwordPolicy.pattern=^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[~`!@#$%^&+=\\-_<>.,?:;*/()|\\[\\]{}'"\\\\]).{16,32}$

#The error message shown to the user in case the password does not follow the regex put in the domibus.passwordPolicy.pattern property
#domibus.passwordPolicy.validationMessage=Minimum length: 16 characters;Maximum length: 32 characters;At least one letter in lowercase;At least one letter in uppercase;At least one digit;At least one special character

#Password expiration policy in days (0 to disable)
#domibus.passwordPolicy.expiration=90

#Default password expiration policy in days (0 to disable)
#domibus.passwordPolicy.defaultPasswordExpiration=15

#Password expiration policy: how many days before expiration should the system warn users at login
#domibus.passwordPolicy.warning.beforeExpiration=15

#Password reuse policy: do not reuse any of the last N passwords (0 to disable)
#domibus.passwordPolicy.dontReuseLast=5

#Default password validation policy enabled/disabled (by default is enabled)
#domibus.passwordPolicy.checkDefaultPassword=true

#Default user creation policy enabled/disabled (by default is enabled)
#domibus.passwordPolicy.defaultUser.create=true

#Default user password generation policy enabled/disabled (by default is enabled)
#domibus.passwordPolicy.defaultUser.autogeneratePassword=true

#Cron expression that specifies the frequency of the password expiration check
#domibus.passwordPolicies.check.cron=0 0 0/1 * * ?

# ---------------------------------- Plugin Users Password Policy -----------------------------------

#Password minimum complexity rules (empty to disable password complexity enforcement)
#domibus.plugin.passwordPolicy.pattern=(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[~`!@#$%^&+=\\-_<>.,?:;*/()|\\[\\]{}'"\\\\]).{16,32}$

#The error message shown to the user in case the password does not follow the regex put in the domibus.plugin.passwordPolicy.pattern property
#domibus.plugin.passwordPolicy.validationMessage=Minimum length: 16 characters;Maximum length: 32 characters;At least one letter in lowercase;At least one letter in uppercase;At least one digit;At least one special character

#Password expiration policy in days (0 to disable)
#domibus.plugin.passwordPolicy.expiration=90

#Default password expiration policy in days (0 to disable)
#domibus.plugin.passwordPolicy.defaultPasswordExpiration=1

#Password reuse policy: do not reuse any of the last N passwords (0 to disable)
#domibus.plugin.passwordPolicy.dontReuseLast=5

#Cron expression that specifies the frequency of the password expiration check
#domibus.plugin_passwordPolicies.check.cron=0 0 0/1 * * ?

# ---------------------------------- Payload -----------------------------------

#It is possible to configure Domibus to save the message payloads on the file system instead of the database. This setting is recommended when exchanging payloads bigger than 30MB.
#In order to enable the file system storage please configure the following property, it is the location on the file system where the payloads will be saved.
#Remark:
#In a cluster configuration the file system storage needs to be accessible by all the nodes from the cluster.
#domibus.attachment.storage.location=your_file_system_location

#Domibus encrypts the payloads stored in the database or file system if this property is active.
#domibus.payload.encryption.active=false

#Cron expression that specifies the frequency of checking if the temporary payloads have expired
#domibus.payload.temp.job.retention.cron=0 0/10 * * * ?

#The threshold in minutes for considering the temporary payloads as expired. The expired temporary payloads are scheduled to be deleted.
#domibus.payload.temp.job.retention.expiration=120

#Temporary files are excluded from deletion if this regular expression matches the file name
#domibus.payload.temp.job.retention.exclude.regex=.*ehcache-sizeof-agent.*

#List of directories to check for cleaning the temporary files.
#domibus.payload.temp.job.retention.directories=domibus.attachment.temp.storage.location

#Limit attachments per message to 28 (count enforced by Apache Santuario library for extended XML signature validation. Ref: https://santuario.apache.org/faq.html#faq-4.SecureValidation)
#domibus.payload.limit.28attachments.per.message=true

#When set to true, Domibus tries to decompress the archived payloads on receiving a message. In case it fails to decompress one payload, an error receipt is returned. Defaults to false.
#domibus.payload.decompression.validation.active=false

# ---------------------------------- Message -----------------------------------

#The suffix of the messageId generated by this instance of domibus. Schema is:  ${UUID}@${SUFFIX}
#domibus.msh.messageid.suffix=domibus.eu

#The maximum size of message in bytes that can be downloaded via admin console
#domibus.message.download.maxSize=10000000

# ---------------------------------- Retry -------------------------------------

#Retry Worker execution interval as a cron expression
#domibus.msh.retry.cron=0/30 * * * * ?

#Retry strategy grants few extra seconds to avoid not sending the last attempt (value in miliseconds, default 30000)
#domibus.msh.retry.messageExpirationDelay=30000

#Retry strategy adds these extra minutes to the interval used to search back for messages in WAITING_FOR_RETRY status. For performance reasons, the interval defaults to 10 minutes.
#When there are older messages in WAITING_FOR_RETRY (e.g. restored messages), increase the interval to capture those messages as well.
#domibus.msh.retry.timeoutDelay=10

# ---------------------------------- Dynamic Discovery -------------------------

#Whether to use dynamic discovery or not
#domibus.dynamicdiscovery.useDynamicDiscovery=false

#The SML zone
#domibus.smlzone=acc.edelivery.tech.ec.europa.eu

#The dynamic discovery client to be used for the dynamic process. Possible values: OASIS and PEPPOL. Defaults to OASIS.
#domibus.dynamicdiscovery.client.specification=OASIS

#Specifies the PEPPOL dynamic discovery client mode: PRODUCTION or TEST mode. Defaults to TEST.
#domibus.dynamicdiscovery.peppolclient.mode=TEST

#Apart from validating response of signer certificates against the truststore, the Oasis Dynamic Discovery Client gives
#the possibility to add (optional) a regular expression to validate the subject of the SMP signer certificate when only issuer chain is added to truststore.
#domibus.dynamicdiscovery.oasisclient.regexCertificateSubjectValidation=^.*EHEALTH_SMP.*$

#Apart from validating response of signer certificates against the truststore, the Peppol Dynamic Discovery Client gives
#the possibility to add (optional) a regular expression to validate the subject of the SMP signer certificate when only issuer chain is added to truststore,
#domibus.dynamicdiscovery.peppolclient.regexCertificateSubjectValidation=.*

# List of certificate policy OIDs separated by comma where at least one must be in the service metadata signer's
# certificate policy extension to consider it as is trusted. Example: 1.3.6.1.4.1.7879.13.25
# (empty value disables the certificate policy validation)
#domibus.dynamicdiscovery.client.allowedCertificatePolicyOIDs=

#The role of the responder PartyId may be defined here
#domibus.dynamicdiscovery.partyid.responder.role=http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/responder

#The type of the PartyId may be defined here (default values are: urn:fdc:peppol.eu:2017:identifiers:ap for PEPPOL and urn:oasis:names:tc:ebcore:partyid-type:unregistered for OASIS
#domibus.dynamicdiscovery.partyid.type=urn:oasis:names:tc:ebcore:partyid-type:unregistered

#The AS4 transport profile by which the endpoint is identified in the SMP response
#domibus.dynamicdiscovery.transportprofileas4=bdxr-transport-ebms3-as4-v1p0

#Global cache property for dynamic discovery lookup caching in seconds
#domibus.dynamicdiscovery.lookup.cache.ttl=3600

# ---------------------------------- JMS ---------------------------------------

#Domibus internal queue used for dispatching the pull requests
#domibus.jms.queue.pull=domibus.internal.pull.queue

#The maximum pool size of the JMS connection factory
#domibus.jms.connectionFactory.maxPoolSize=100

#The maximum number of pending messages to be listed from the backend notification queue. Setting this property is expected to avoid timeouts due to huge resultsets being served.
#Setting this property to zero returns all pending messages
#domibus.listPendingMessages.maxCount=10000

#The maximum number of messages to be listed from the JMS queues. Setting this property is expected to avoid timeouts due to huge results being served.
#Setting this property to zero returns all messages
#domibus.jms.queue.maxBrowseSize=10000

#Domibus internal queue used for alerts
#domibus.jms.queue.alert=domibus.internal.alert.queue

#Concurrency configured for executing internal commands
#domibus.jms.internal.command.concurrency=1-1

#The desired size for the JMS Session cache
#domibus.jms.connectionFactory.session.cache.size=1

# ---------------------------------- Validation --------------------------------

#If activated Domibus will verify before sending a message if the receiver's certificate is valid and not revoked. If the receiver's certificate
#is not valid or it has been revoked Domibus will not send the message and it will mark it as SEND_FAILURE (default is true)
#domibus.receiver.certificate.validation.onsending=true

#If activated Domibus will verify before sending a message if his own certificate is valid and not revoked. If the certificate is not valid
#or it has been revoked Domibus will not send the message and it will mark it as SEND_FAILURE (default is true)
#domibus.sender.certificate.validation.onsending=true

#If activated Domibus will verify before receiving a message if the sender's certificate is valid and not revoked. If the certificate is
#not valid or it has been revoked Domibus will not accept the message (default is true)
#domibus.sender.certificate.validation.onreceiving=true

#If activated Domibus will verify before receiving a message, the validity and authorization on the sender's certificate. When disabled,
#none of the other checks are performed on the sender's certificate.
#domibus.sender.trust.validation.onreceiving=true

#When this property is not empty Domibus will verify before receiving a message, that the subject of the sender's certificate matches the regular expression.
#domibus.sender.trust.validation.expression=

# List of certificate policy OIDs separated by comma. When this property is not empty Domibus will verify before receiving a message,
# that certificate contains at lest one certificate policy OID in certificatePolicy extension to consider it as is trusted.
# List of certificate policy OIDs separated by comma where at least one must be in the service metadata signer's
#domibus.sender.trust.validation.allowedCertificatePolicyOIDs=

#When enabled, Domibus will verify before receiving a message, that the alias (party name) is present in the signing certificate subject.
#domibus.sender.certificate.subject.check=false

#When enabled, Domibus will verify before receiving a message, that the sender's certificate matches the certificate in the truststore,
#loaded based on the alias (party name)
#domibus.sender.trust.validation.truststore_alias=true

#Accepted Format for MessageId (Default value, based on RFC2822 [CORE 5.2.2.1]: ^[\\x20-\\x7E]*$ )
#domibus.sendMessage.messageIdPattern=^[\\x20-\\x7E]*$

#Accepted Format for xsd:datetime for AS4 communication
#domibus.datetime.pattern.onreceiving=yyyy-MM-dd'T'HH:mm:ss[.SSSSSSSSS][.SSSSSS][.SSS][z]

#Format of xsd:datetime used for AS4Receipt
#domibus.datetime.pattern.onsending=yyyy-MM-dd'T'HH:mm:ss.SSS'Z'

#Validate PartyInfo From/To initiator and responder roles. This property helps maintaining backwards compatibility. It is recommended to be enabled. By default enabled.
#domibus.partyinfo.roles.validation.enabled=true

#Validate the qualified name of the Mpc in the received UserMessage on MSH endpoint matches the qualified name of the Mpc configured on the pMode leg configuration
#domibus.pmode.legconfiguration.mpc.validation.enabled=true

# ---------------------------------- Dispatcher --------------------------------

#Timeout values for communication between the access points
#ConnectionTimeOut - Specifies the amount of time, in milliseconds, that the consumer will attempt to establish a connection before it times out. 0 is infinite.
#domibus.dispatcher.connectionTimeout=60000

#ReceiveTimeout - Specifies the amount of time, in milliseconds, that the consumer will wait for a response before it times out. 0 is infinite.
#domibus.dispatcher.receiveTimeout=60000

#Allows chunking when sending messages to other Access Points
#domibus.dispatcher.allowChunking=false

#If domibus.dispatcher.allowChunking is true, this property sets the threshold at which messages start getting chunked(in bytes). Messages under this limit do not get chunked. Defaults to 100 MB.
#domibus.dispatcher.chunkingThreshold=104857600

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when sending messages to other Access Points
#domibus.dispatcher.concurency=5-20

#The timeout of the dispatcher JMS queue transaction(in seconds)
#domibus.dispatcher.timeout=300

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when sending large messages(SplitAndJoin) to other Access Points
#domibus.dispatcher.largeFiles.concurrency=1

#Cache the dispatcher clients used for communication between the access points. Defaults to true.
#domibus.dispatcher.cacheable=true

#Specifies if the connection will be kept alive between C2 and C3. Default value is true.
#domibus.dispatcher.connection.keepAlive=true

#Priority rules used to assign a specific JMS priority for dispatched messages. Multiple rules can be defined. Rules names must be unique in order to avoid name collision.
#More information about using priority rules can be found in the Admin Guide document.

#Priority rule name. The rule name will be further used to specify additional rule properties.
#domibus.dispatcher.priority.rule1=Priority rule description

#Service value to be matched against the sent message
#domibus.dispatcher.priority.rule1.service=ServiceValue

#List of actions separated by comma to be matched against the sent message
#domibus.dispatcher.priority.rule1.action=action1,action2,action3

#Priority value assigned to the JMS message. Accepted priority values must be between 1-9 included.
#domibus.dispatcher.priority.rule1.value=5

#(optional) Domibus creates a dedicated JMS listener for the rule in case this property is defined. More information can be found in the Admin Guide.
#domibus.dispatcher.priority.rule1.concurrency=5-10

# ---------------------------------- Task Executor -----------------------------

#Use the below property to customize the task executor threads count. Defaults to 200.
#domibus.taskExecutor.threadCount=200

#Use the below property to customize the msh endpoint task executor threads count. Defaults to 200.
#domibus.mshTaskExecutor.threadCount=200

# ---------------------------------- Retention ---------------------------------

#Cron expression used for configuring the retention worker scheduling. The retention worker deletes the expired messages(downloaded and not-downloaded).
#domibus.retentionWorker.cronExpression=0 0/1 * * * ?

#Uncomment the following line if you need to tweak the maximum downloaded messages to be deleted by the retention worker. Defaults to 50.
#domibus.retentionWorker.message.retention.downloaded.max.delete=50

#Uncomment the following line if you need to tweak the maximum not-downloaded messages to be deleted by the retention worker. Defaults to 50.
#domibus.retentionWorker.message.retention.not_downloaded.max.delete=50

#Uncomment the following line if you need to tweak the maximum sent messages to be deleted by the retention worker. Defaults to 50.
#domibus.retentionWorker.message.retention.sent.max.delete=50

#Uncomment the following line if you need to tweak the maximum messages with payload deleted to be fully deleted by the retention worker. Defaults to 50.
#domibus.retentionWorker.message.retention.payload_deleted.max.delete=50

#Define the deletion strategy. Possible values are: DEFAULT, PARTITIONS (Oracle only)
#domibus.retentionWorker.deletion.strategy=DEFAULT

### Configure next properties depending on the selected deletion strategy
### ---------------------------------- Retention - Deletion Strategy DEFAULT ---------------------------------

#Maximum number of messages to be deleted by the retention worker in a bulk delete (when not specified in the pMode MPC). Defaults to 1000, maximum allowed when using Oracle database.
#domibus.retentionWorker.message.retention.batch.delete=1000

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when deleting messages
#domibus.retention.jms.concurrency=5-10

### ---------------------------------- Retention - Deletion Strategy PARTITIONS ---------------------------------
#Cron expression used for configuring the partition worker scheduling. The partition worker verifies if partitions were properly created in advance
#domibus.partitions.worker.cron=0 9 * * * ?

#Number of days to check if partitions were successfully created in advance. Defaults to 7 days.
#domibus.partitions.creation.days_to_check=7

#When set to true, before dropping a partition, verifies if all messages on that partition were previously archived.
#This check is a guard rail for dropping partitions when the earchiving mechanism is disabled. Default is true.
#domibus.partitions.drop.check.messages.earchived=true

# ---------------------------------- Proxy -------------------------------------
#domibus.proxy.enabled=false
#domibus.proxy.http.host=
#domibus.proxy.http.port=
#domibus.proxy.user=
#domibus.proxy.password=
#domibus.proxy.nonProxyHosts=

# ---------------------------------- ActiveMQ ----------------------------------

#The host of the JMS broker
#activeMQ.broker.host=localhost

#The name of the JMS broker
#activeMQ.brokerName=localhost

#The configuration file of the embedded ActiveMQ broker. IN case an external broker is used this property is not needed and it should be removed
activeMQ.embedded.configurationFile=file:///${domibus.config.location}/internal/activemq.xml

#The service URL of the MBeanServer
#activeMQ.JMXURL=service:jmx:rmi:///jndi/rmi://${activeMQ.broker.host}:${activeMQ.connectorPort}/jmxrmi

#The port that the JMX connector will use for connecting to ActiveMQ
#activeMQ.connectorPort=1199

#The connection URI that the clients can use to connect to an ActiveMQ broker using a TCP socket
#activeMQ.transportConnector.uri=tcp://${activeMQ.broker.host}:61616

#The username that is allowed to connect to the ActiveMQ broker
#activeMQ.username=domibus

#THe password of the username defined in the activeMQ.username property
#activeMQ.password=changeit

#The persistence enabled flag
#activeMQ.persistent=true

#Sets the timeout before a close is considered complete
#activeMQ.connection.closeTimeout=15000

#Sets the connection response timeout
#activeMQ.connection.connectResponseTimeout=0

# ---------------------------------- Pulling-----------------------------------

#Cron expression used for configuring the message puller scheduling.
#domibus.msh.pull.cron=0 0 0/1 * * ?

# Number of threads used to parallelize the pull requests.
#domibus.pull.queue.concurency=1-1

# Number of threads used to parallelize the pull receipts.
#domibus.pull.receipt.queue.concurrency=5-20

#Number or requests per MPC executed every cron cycle. Generic value that applies to all MPCs.
#domibus.pull.request.send.per.job.cycle=1

#Optional number or requests per specific MPC executed every cron cycle.
#Takes precedence over the generic "domibus.pull.request.send.per.job.cycle property" value.
#MPCs are indicated by their short names.
#domibus.pull.request.send.per.job.cycle.per.mpc.MPC_NAME=1

#Time in second for the system to recover its full pull capacity when job schedule is one execution per second.
#If configured to 0, no incremental frequency is executed and the pull pace is executed at its maximum.
#domibus.pull.request.frequency.recovery.time=0

#Number of connection failure before the system decrease the pull pace.
#domibus.pull.request.frequency.error.count=10

#Pull Retry Worker execution interval as a cron expression
#domibus.pull.retry.cron=0/10 * * * * ?

#Allow dynamic initiator on pull requests - 0 or multiple initiators are allowed in the Pmode process
#domibus.pull.dynamic.initiator=false

#Allow multiple legs configured on the same pull process (with the same security policy)
#domibus.pull.multiple_legs=false

#Force message into READY_TO_PULL when mpc attribute is present (default is false)
#domibus.pull.force_by_mpc=false

#Mpc initiator separator. This is used when the mpc provides information on the initiator: baseMpc/SEPARATOR/partyName
#domibus.pull.mpc_initiator_separator=PID

# ---------------------------------- Alert management -----------------------------------
#Enable/disable the entire alert module. Pay attention to the fact that if the module is activated, all properties
#under the mandatory section should be configured.
#domibus.alert.active=true

#Allow to disable alert mail sending.
#domibus.alert.mail.sending.active=false

#SMTP Socket I/O timeout value in milliseconds
#domibus.alert.mail.smtp.timeout=5000

# -----------------------------------Mandatory configuration start (if domibus.alert.active=true and domibus.alert.mail.sending.active=true) -----------

#Smtp server url for sending alert.
#domibus.alert.sender.smtp.url=

#Smtp server port.
#domibus.alert.sender.smtp.port=

#(optional) Smtp server user.
#domibus.alert.sender.smtp.user=

#(optional) Smtp server user password.
#domibus.alert.sender.smtp.password=

#Alert sender email.
#domibus.alert.sender.email=

#Alert email receiver. You can specify multiple recipients by using semicolon separated email addresses:name1@gmail.com;name2@gmail.com
#domibus.alert.receiver.email=

# ----------------------------------Mandatory configuration end-----------------------------------

#The following properties can stay commented if no modifications to the default values are needed.

#Cron configuration for cleaning alerts.
#domibus.alert.cleaner.cron=0 0 0/1 * * ?

#Lifetime in days of alerts before cleaning.
#domibus.alert.cleaner.alert.lifetime=20

#Concurency to process the alerts.
#domibus.alert.queue.concurrency=1

#Frequency of failed alerts retry.
#domibus.alert.retry.cron=0 0/10 * * * ?

#Elapsed time in minutes between alert retry.
#domibus.alert.retry.time=10

#Maximum number of attempts for failed alerts
#domibus.alert.retry.max_attempts=2

# ---------------------------------- Alert management:messaging module -----------------

#Enable/disable the messaging alert module.
#domibus.alert.msg.communication_failure.active=true

#Message status change that should be notified by the messaging alert module. Comma separated.
#domibus.alert.msg.communication_failure.states=SEND_FAILURE

#Alert levels corresponding to message status defined in previous property(domibus.alert.msg.communication_failure.states) .
#Should be (HIGH, MEDIUM OR LOW)
#domibus.alert.msg.communication_failure.level=HIGH

#Messaging alert module mail subject.
#domibus.alert.msg.communication_failure.mail.subject=Message status change

# ---------------------------------- Alert management:Authentication module -----------------

#Enable/disable the login failure alert of the authentication module.
#domibus.alert.user.login_failure.active=true

#Alert level for login failure.
#domibus.alert.user.login_failure.level=LOW

#Login failure mail subject.
#domibus.alert.user.login_failure.mail.subject=Login failure

#Enable/disable the account disable alert of the authentication module.
#domibus.alert.user.account_disabled.active=true

#Alert level for account disabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
#domibus.alert.user.account_disabled.level=HIGH

#When should the account disabled alert be triggered.
# 2 possible values:
# AT_LOGON: An alert will be triggered each time a user tries to login to a disabled account.
# WHEN_BLOCKED: An alert will be triggered once when the account got disabled.
#domibus.alert.user.account_disabled.moment=WHEN_BLOCKED

#Account disabled mail subject.
#domibus.alert.user.account_disabled.subject=Account disabled

#Enable/disable the account enabled alert of the authentication module.
#domibus.alert.user.account_enabled.active=false

#Alert level for account enabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
#domibus.alert.user.account_enabled.level=MEDIUM

#Account enabled mail subject.
#domibus.alert.user.account_enabled.subject=Account enabled

# ---------------------------------- Alert management:Certificate scanner -----------------

#Enable/disable the imminent certificate expiration alert of certificate scanner module.
#domibus.alert.cert.imminent_expiration.active=true

#Number of days before revocation as from when the system should start sending alerts.
#domibus.alert.cert.imminent_expiration.delay_days=60

#Frequency in days between alerts.
#domibus.alert.cert.imminent_expiration.frequency_days=14

#Certificate imminent expiration alert level.
#domibus.alert.cert.imminent_expiration.level=HIGH

#Certificate imminent expiration mail subject.
#domibus.alert.cert.imminent_expiration.mail.subject=Certificate imminent expiration

#Enable/disable the certificate expired alert of certificate scanner module.
#domibus.alert.cert.expired.active=true

#Frequency in days between alerts.
#domibus.alert.cert.expired.frequency_days=7

#How long(in days) after the revocation should the system trigger alert for the expired certificate.
#domibus.alert.cert.expired.duration_days=90

#Certificate expired alert level.
#domibus.alert.cert.expired.level=HIGH

#Certificate expired mail subject.
#domibus.alert.cert.expired.mail.subject=Certificate expired

# ---------------------------------- Alert management:Password policy  -----------------

#Enable/disable the imminent password expiration alert
#domibus.alert.password.imminent_expiration.active=true

#Number of days before expiration as for how long before expiration the system should send alerts.
#domibus.alert.password.imminent_expiration.delay_days=15

#Frequency in days between alerts.
#domibus.alert.password.imminent_expiration.frequency_days=3

#Password imminent expiration alert level.
#domibus.alert.password.imminent_expiration.level=LOW

#Password imminent expiration mail subject.
#domibus.alert.password.imminent_expiration.mail.subject=Password imminent expiration

#Enable/disable the imminent password expiration alert
#domibus.alert.password.expired.active=true

#Number of days after expiration as for how long the system should send alerts.
#domibus.alert.password.expired.delay_days=30

#Frequency in days between alerts.
#domibus.alert.password.expired.frequency_days=5

#Password expiration alert level.
#domibus.alert.password.expired.level=LOW

#Password expiration mail subject.
#domibus.alert.password.expired.mail.subject=Password expired

# ---------------------------------- Alert management: Plugin Password policy  -----------------

#Enable/disable the imminent password expiration alert
#domibus.alert.plugin_password.imminent_expiration.active=true

#Number of days before expiration as for how long before expiration the system should send alerts.
#domibus.alert.plugin_password.imminent_expiration.delay_days=15

#Frequency in days between alerts.
#domibus.alert.plugin_password.imminent_expiration.frequency_days=3

#Password imminent expiration alert level.
#domibus.alert.plugin_password.imminent_expiration.level=LOW

#Password imminent expiration mail subject.
#domibus.alert.plugin_password.imminent_expiration.mail.subject=Password imminent expiration

#Enable/disable the imminent password expiration alert
#domibus.alert.plugin_password.expired.active=true

#Number of days after expiration as for how long the system should send alerts.
#domibus.alert.plugin_password.expired.delay_days=30

#Frequency in days between alerts.
#domibus.alert.plugin_password.expired.frequency_days=5

#Password expiration alert level.
#domibus.alert.plugin_password.expired.level=LOW

#Password expiration mail subject.
#domibus.alert.plugin_password.expired.mail.subject=Password expired

# ---------------------------------- Alert management:Authentication module for Plugin users-----------------

#Enable/disable the login failure alert of the authentication module.
#domibus.alert.plugin.user.login_failure.active=true

#Alert level for login failure.
#domibus.alert.plugin.user.login_failure.level=LOW

#Login failure mail subject.
#domibus.alert.plugin.user.login_failure.mail.subject=Login failure

#Enable/disable the account disable alert of the authentication module.
#domibus.alert.plugin.user.account_disabled.active=true

#Alert level for account disabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
#domibus.alert.plugin.user.account_disabled.level=HIGH

#When should the account disabled alert be triggered.
# 2 possible values:
# AT_LOGON: An alert will be triggered each time a user tries to login to a disabled account.
# WHEN_BLOCKED: An alert will be triggered once when the account got disabled.
#domibus.alert.plugin.user.account_disabled.moment=WHEN_BLOCKED

#Account disabled mail subject.
#domibus.alert.plugin.user.account_disabled.subject=Account disabled

#Enable/disable the account enabled alert of the authentication module.
#domibus.alert.plugin.user.account_enabled.active=false

#Alert level for account enabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
#domibus.alert.plugin.user.account_enabled.level=MEDIUM

#Account enabled mail subject.
#domibus.alert.plugin.user.account_enabled.subject=Account enabled

# ---------------------------------- Alert management: Partitions -----------------
#Frequency in days between alerts.
#domibus.alert.partition.check.frequency_days=1

# ---------------------------------- Alert management: E-Archiving Module -----------------
#Enable/disable the EArchiving notification failed alerts.
#domibus.alert.earchive.notification.active=true

#EArchiving notification failed alert level.
#domibus.alert.earchive.notification.level=MEDIUM

#EArchiving notification failed mail subject.
#domibus.alert.earchive.notification.mail.subject=E-Archiving client notification failed

# ---------------------------------- Various -----------------------------------

#The factory for creating SOAPMessage objects
#messageFactoryClass=com.sun.xml.messaging.saaj.soap.ver1_2.SOAPMessageFactory1_2Impl

#If disabled, Domibus will not notify the plugins when the state of the User Message changes. Defaults to true.
#domibus.plugin.notification.active=true

#If disabled, Domibus will not save the non repudiation audit data. Defaults to true.
#domibus.nonrepudiation.audit.active=true

#The list of mime-types that will not be compressed (in outgoing messages) even if compression is turned on for the given message.
#compressionBlacklist=application/vnd.etsi.asic-s+zip,image/jpeg

#Whether to delete the message payload on send failure. Defaults to false (the administrator can put the message back in the send queue).
#domibus.sendMessage.failure.delete.payload=false

#Whether to delete the message payload on send success. Defaults to true (preserves backwards compatibility).
#domibus.sendMessage.success.delete.payload=true

#If disabled, Domibus will not save the message attempt details when there is a failure sending a message. Defaults to true.
#domibus.sendMessage.attempt.audit.active=true

#Should unrecoverable errors be retried or not
#domibus.dispatch.ebms.error.unrecoverable.retry=true

#Number of threads used to parallelize the dispatching of messages to the plugins.
#domibus.internal.queue.concurency=3-10

#finalRecipient and originalSender properties are used in filtering the messages on GUI. Defaults to true.
#domibus.fourcornermodel.enabled=true

#characters that are not accepted in user input
#domibus.userInput.blackList='\u0022(){}[];,+=%&*#<>/\\

#characters that are accepted in user input
#domibus.userInput.whiteList=

#The maximum length accepted for a property value, in bytes. Defaults to 10000.
#domibus.property.length.max=10000

#Enables the validation of domibus properties values (defaults to true)
#domibus.property.validation.enabled=true

#Prints the AS4 payload in the logs while org.apache.cxf is set to at least INFO in logback.xml. Defaults to false.
#domibus.logging.payload.print=false

#Prints the AS4 metadata in the logs when org.apache.cxf is set to at least INFO in logback.xml. Defaults to true.
#domibus.logging.metadata.print=true

#prints the raw XML response in the logs in case of EBMS3 error on receiver/sender side (if eu.domibus is put at least on ERROR)
#domibus.logging.ebms3.error.print=true

#The size limit at which messages are truncated in the logs when org.apache.cxf is set to at least INFO in logback.xml
# Number between 0 and 1000000000 bytes
# Defaults to limit (18000 bytes)
#domibus.logging.cxf.limit=18000

#Disables offloading the SSL connection to another application - e.g. SSL Forward Proxy - (defaults to false)
#domibus.connection.cxf.ssl.offload.enable=false

#The maximum file size in bytes that can be uploaded through REST ( pMode, trustStore)
#domibus.file.upload.maxSize=10000000

#How long(in seconds) HSTS should last in the browser's cache(default one year)
#domibus.httpSecurity.httpStrictTransportSecurity.maxAge=31536000

# ------------------------------- Domibus instance/environment name ------------------

#domibus.instance.name = Domibus

# ---------------------------------- Metrics -----------------

#Enable jmx reporter for dropwizard metrics. The following warning:
#We do not recommend that you try to gather metrics from your production environment.JMX's RPC API is fragile.
#For development purposes and browsing, though, it can be very useful.
#domibus.metrics.jmx.reporter.enable=false

#Enable sl4j reporter for dropwizard metrics.
#domibus.metrics.sl4j.reporter.enable=true

#The time unit used to configure the frequency of writing statistics into the statistic.log file.
#Possible values are:SECONDS, MINUTES, HOURS
#domibus.metrics.sl4j.reporter.period.time.unit=MINUTES

#The number of period of the previously time unit used to configure the frequency of writing statistics into the statistic.log file.
#EG: the default configuration will write statistics with the file every 1 MINUTE.
#domibus.metrics.sl4j.reporter.period.number=1

#Activate drop wizard memory metrics
#domibus.metrics.monitor.memory=true

#Activate drop wizard gc metrics
#domibus.metrics.monitor.gc=true

#Activate drop wizard cached threads metrics
#domibus.metrics.monitor.cached.threads=true

#Activate drop wizard JMS Queues metrics
#domibus.metrics.monitor.jms.queues=true

# how long (in seconds) the JMS count will be cached
# defaults to 10
#domibus.metrics.monitor.jms.queues.refresh.period=10

# show counts only for DLQ queue
#domibus.metrics.monitor.jms.queues.show.dlq.only=true

# ------------------------------- SplitAndJoin ---------------------------------------

#SplitAndJoin only: Domibus uses a  file system location for storing temporary data when processing SplitAndJoin messages
#In a cluster configuration the temporary file system storage needs to be accessible by all the nodes from the cluster.
#domibus.attachment.temp.storage.location=your_temporary_file_system_location

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when sending the SourceMessage receipt(Split and Join) to other Access Points
#domibus.dispatcher.splitAndJoin.concurrency=1

#The threshold value in MB to switch from synchronous to asynchronous saving of outgoing SourceMessage payloads
#domibus.dispatcher.splitAndJoin.payloads.schedule.threshold=1000

#Cron expression that specifies the frequency of the checking if the joinInterval has expired
#domibus.splitAndJoin.receive.expiration.cron=0 0/5 * * * ?

# --------------------------- Connection Monitoring ----------------------------------

#Specifies the parties for which to monitor the connection (comma-separated list)
#domibus.monitoring.connection.party.enabled=

#Cron expression that specifies the frequency of test messages sent to monitor the C2-C3 connections
#domibus.monitoring.connection.cron=0 0 0/2 ? * * *

# --------------------------------------------Error Logs-------------------------------

#Cron configuration for cleaning error logs without message ids.
#domibus.errorlog.cleaner.cron=0 0 0/1 * * ?

#Cron job will delete error logs without message ids older than this property days
#domibus.errorlog.cleaner.older.days=100

#how maximum error logs will be deleted for each job run
#domibus.errorlog.cleaner.batch.size=5000

# --------------------------------------------EArchiving-------------------------------
#Domibus allows for e-archiving if activated
#domibus.earchive.active=false

#In a cluster configuration the earchive file system storage needs to be accessible by all the nodes from the cluster.
#domibus.earchive.storage.location=your_file_system_location

#Allows to create empty export batches if no messages are found. If false, no batch nor files created when no messages found.
#domibus.earchive.export.empty=false

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#for the earchiving queue
#domibus.earchive.queue.concurrency=1-1

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when notify batches updates to other EArchive client
#domibus.earchive.notification.queue.concurrency=1-1

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when error in notifying batches updates to other EArchive client
#domibus.earchive.notification.dlq.concurrency=1-1

#Cron configuration for executing the earchiving continuous process.
#domibus.earchive.cron=0 0 0/1 * * ?

#Cron configuration for executing the earchiving sanity process.
#domibus.earchive.sanitizer.cron=0 0 0/1 * * ?

#Cron configuration for executing the earchiving cleanup process.
#domibus.earchive.retention.cron=0 0 0/2 * * ?

#maximum messages to be archived for one batch
#domibus.earchive.batch.size=5000

#maximum earchive batches to be created during one job
#domibus.earchive.batch.max=10

#Timeout used to retrieve the messages in minutes. Defaults to 0.
# WARNING: this value is rounded to the previous whole hour to limit the messages search scope
# (ex: runtime = 15h12 | if retry.timeout=5  -> latest time for a message to be taken into account: 15h00 and earlier
#                      | if retry.timeout=30 -> latest time for a message to be taken into account: 14h00 and earlier)
#-1 disables this functionality and retrieve the timeout with the loaded PMode
#domibus.earchive.batch.retry.timeout=0

#Endpoint where the e-archiving client receives notifications
#domibus.earchive.notification.url=

#The user used to access the endpoint of the e-archiving client
#domibus.earchive.notification.username=

#The password used to access the endpoint of the e-archiving client
#domibus.earchive.notification.password=

#Timeout used when notifying the e-archiving client
#domibus.earchive.notification.timeout=5000

#Specify whether to use a proxy when notifying the e-archiving client
#domibus.earchive.notification.useProxy=false

# For methods: History Of Exports and enqueued batches, also return message list as part of batches objects.
# Note: in case of large batch size returning message list in all of the batches in a list will slow down the response time of the services.
#domibus.earchive.rest.messages.return=false

#If a batch is not archived during this time, it is considered as expired
#domibus.earchive.retention.days=30

#Maximum number of earchive batches to delete at a time
#domibus.earchive.retention.delete.max=5000

#An alert is sent if the start date of the continuous job was not updated between now and now - allowed_window (in hours)
#domibus.earchive.start_date.stopped.allowed_hours=24

#Enable/disable the Earchive non final message alert.
#domibus.alert.earchive.messages_non_final.active=true

#Alert level for Earchive non final message.
#domibus.alert.earchive.messages_non_final.level=HIGH

#Earchive non final message mail subject.
#domibus.alert.earchive.messages_non_final.mail.subject=Earchive: message not in final state

#Enable/disable the Earchive start date stopped alert.
#domibus.alert.earchive.start_date_stopped.active=true

#Alert level for Earchive start date stopped.
#domibus.alert.earchive.start_date_stopped.level=HIGH

#Earchive start date stopped mail subject.
#domibus.alert.earchive.start_date_stopped.mail.subject=Earchive: continuous job start date stopped

#Enable if e-archiving client needs to receive notifications with additional details like message start date and end date
#domibus.earchive.notification.details.enabled=false

# --------------------------------------------Quartz-------------------------------
#Specifies the amount of time, in milliseconds that used to check if any quartz triggers are blocked. Default value is 10 minutes.
#domibus.quartz.trigger.blocked.duration=600000

# ------------------------------------------------------------------------------------
