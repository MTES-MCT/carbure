# ---------------------------------- Cluster -----------------------------------

#Specifies if Domibus should run in cluster mode. This affects for instance whether the Quartz jobs are clustered.
#domibus.deployment.clustered=false

#In cluster mode, specifies if the database synchronization mechanism should be used when initializing the Quartz scheduler
#domibus.scheduler.bootstrap.synchronized=true

#Timeout for the database synchronization mechanism, in milliseconds
#domibus.synchronization.timeout=10000

# ---------------------------------- GUI -------------------------

# The title shown in the Tab of Admin Console (default value: "Domibus")
#domibus.ui.title.name=Domibus

#support team name
#domibus.ui.support.team.name=EDELIVERY Support Team

#support team email
#domibus.ui.support.team.email=CEF-EDELIVERY-SUPPORT@ec.europa.eu

#Max rows for CSV export
#domibus.ui.csv.rows.max=10000

# how many minutes after message's received date the Resend button will become enabled for messages having SEND_ENQUEUED status
#domibus.ui.resend.action.enabled.received.minutes=5

#The limit when calculating the number of message logs(disabled when 0)
#domibus.ui.pages.messageLogs.countLimit=50000

#The initial/default interval (in hours) for filtering messages
#domibus.ui.pages.messageLogs.interval.default=24

#Whether the Messages page should be the default landing page after login (defaults to true, but should be set to false in high load environments)
#domibus.ui.pages.messageLogs.landingPage.enabled=true

#Whether the Messages page has all the advanced capabilities (defaults to true, but should be set to false in high load environments)
#domibus.ui.pages.messageLogs.search.advanced.enabled=true

#Used to secure the session of admin console; set to true only in conjunction with https protocol
#domibus.ui.session.secure=false

#Used to set the the session timeout of admin console ( in minutes )
#domibus.ui.session.timeout=30

#Used to set the SameSite attribute of cookies (session and all others) used by the admin console. Possible values are: Strict, None, Lax
#domibus.ui.session.sameSite=Strict

#Used to which JVM to route to for session affinity ensuring that the value of the session cookie is formatted as
#'sessionId + "." + jvmRoute'; the jvmRoute can be the name of an environment variable or a Java system property
#(default empty, i.e. no session affinity)
#domibus.ui.session.jvmroute=

# ---------------------------------- Keystore/Truststore (Single Tenancy) -----------------------

#The initial location of the keystore; used only the first time domibus starts and persisted in the DB to be used from there on
domibus.security.keystore.location=${domibus.config.location}/keystores/gateway_keystore.jks

#The type of the used keystore
domibus.security.keystore.type=jks

#The password used to load the keystore
domibus.security.keystore.password=$DOMIBUS_SECURITY_KEYSTORE_PASSWORD

#Private key
#The alias from the keystore of the private key
domibus.security.key.private.alias=$DOMIBUS_SECURITY_KEY_PRIVATE_ALIAS

#The private key password
domibus.security.key.private.password=$DOMIBUS_SECURITY_KEY_PRIVATE_PASSWORD

# --- Truststore ---
#The initial location of the truststore; used only the first time domibus starts and persisted in the DB to be used from there on
domibus.security.truststore.location=${domibus.config.location}/keystores/gateway_truststore.jks

#Type of the used truststore
domibus.security.truststore.type=jks

#The password used to load the trustStore
domibus.security.truststore.password=$DOMIBUS_SECURITY_TRUST_PASSWORD

# ------------- Security Profiles -------------------

#For enabling Security Profiles for signing and encryption uncomment the following parameters accordingly

# --- RSA Profile ---

#Sign
#domibus.security.key.private.rsa.sign.alias=blue_gw_rsa_sign
#domibus.security.key.private.rsa.sign.password=test123
#domibus.security.key.private.rsa.sign.type=RSA

#Decrypt
#domibus.security.key.private.rsa.decrypt.alias=blue_gw_rsa_decrypt
#domibus.security.key.private.rsa.decrypt.password=test123
#domibus.security.key.private.rsa.decrypt.type=RSA

# --- ECC Profile ---

#Sign
#domibus.security.key.private.ecc.sign.alias=blue_gw_ecc_sign
#domibus.security.key.private.ecc.sign.password=test123
#The type property specifies the algorithm type of the message signing certificate. Instead of the algorithm type name, the corresponding curve identifier will pe specified.
#One or more algorithm types can be specified, comma-separated.
#For eg. "1.3.101.112" is the identifier of the ED25519 algorithm's curve. ECDSA algorithms can be used as well.
#domibus.security.key.private.ecc.sign.type=1.3.101.112

#Decrypt
#domibus.security.key.private.ecc.decrypt.alias=blue_gw_ecc_decrypt
#domibus.security.key.private.ecc.decrypt.password=test123
#The type property specifies the algorithm type of the message decryption certificate. Instead of the algorithm type name, the corresponding curve identifier will pe specified.
#One or more algorithm types can be defined, comma-separated.
#For eg. "1.3.101.112" is the identifier of the X25519 algorithm's curve and "1.3.101.111" is the identifier of the X448 algorithm's curve. Other curves can be used as well.
#domibus.security.key.private.ecc.decrypt.type=1.3.101.110,1.3.101.111

#Priority order of Security Profiles used in Dynamic Discovery to set the Transport Profile
#domibus.security.profile.order=ECC,RSA

# ---------------------------------- Database ----------------------------------

#Database server name
domibus.database.serverName=$DOMIBUS_DATABASE_SERVERNAME

#Database port
domibus.database.port=$DOMIBUS_DATABASE_PORT

#General schema. If uncommented Domibus will run in multi-tenancy mode.
#domibus.database.general.schema=general_schema

#Database schema.
#Please comment this property when Domibus is configured in multi-tenancy mode.
#Please comment this property when Domibus is configured in single tenancy mode with an Oracle database.
domibus.database.schema=$DOMIBUS_DATABASE_SCHEMA

#Non-XA Datasource
#MySQL
#Connector/J 8.0.x
domibus.datasource.driverClassName=com.mysql.cj.jdbc.Driver
domibus.datasource.url=jdbc:mysql://${domibus.database.serverName}:${domibus.database.port}/${domibus.database.schema}?allowPublicKeyRetrieval=true&useSSL=false&useLegacyDatetimeCode=false&serverTimezone=UTC

#Oracle
#domibus.datasource.driverClassName=oracle.jdbc.OracleDriver
#domibus.datasource.url=jdbc:oracle:thin:@${domibus.database.serverName}:${domibus.database.port}/XE

domibus.datasource.user=$DOMIBUS_DATASOURCE_USER
domibus.datasource.password=$DOMIBUS_DATASOURCE_PASSWORD

#HikariCP specific
#Controls the maximum lifetime of a connection in the pool (in seconds)
#domibus.datasource.maxLifetime=1800

#Controls the maximum amount of time (in seconds) that a client will wait for a connection from the pool
#domibus.datasource.connectionTimeout=30

#Controls the maximum amount of time (in seconds) that a connection is allowed to sit idle in the pool
#domibus.datasource.idleTimeout=600

#Controls the maximum size that the pool is allowed to reach, including both idle and in-use connections
#domibus.datasource.maxPoolSize=10

#Controls the minimum number of idle connections that HikariCP tries to maintain in the pool
#domibus.datasource.minimumIdle=10

#Represents a user-defined name for the connection pool and appears mainly in logging and JMX management consoles; empty to auto-generate
#domibus.datasource.poolName=

# ---------------------------------- EntityManagerFactory ----------------------

#Packages to be scanned(comma separated)
#domibus.entityManagerFactory.packagesToScan=eu.domibus

#Number of rows fetched when there is more than a one row result on select statements (use only for Oracle, for MySQL JDBC driver caches the entire result set up front, so no need to set the fetch size)
#domibus.entityManagerFactory.jpaProperty.hibernate.jdbc.fetch_size=50

#MySQL
#Connector/J 8.0.x
domibus.entityManagerFactory.jpaProperty.hibernate.connection.driver_class=com.mysql.cj.jdbc.Driver

domibus.entityManagerFactory.jpaProperty.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
domibus.entityManagerFactory.jpaProperty.hibernate.id.new_generator_mappings=false

#Oracle
#domibus.entityManagerFactory.jpaProperty.hibernate.connection.driver_class=oracle.jdbc.driver.OracleDriver
#domibus.entityManagerFactory.jpaProperty.hibernate.dialect=org.hibernate.dialect.Oracle10gDialect

#Enable or disable the formatting of SQL statements generated by Hibernate
#domibus.entityManagerFactory.jpaProperty.hibernate.format_sql=true

#Second level cache provider (use "infinispan" for Infinispan and "eu.domibus.core.cache.DomibusCacheRegionFactory" for Ehcache)
#domibus.entityManagerFactory.jpaProperty.hibernate.cache.region.factory_class=infinispan

#Infinispan specific: infinispan config file
#domibus.entityManagerFactory.jpaProperty.hibernate.cache.infinispan.cfg=config/infinispan/domibus-infinispan-default.xml

#Infinispan specific: factory for second level cache keys. For other cache providers it should be left empty.
#domibus.entityManagerFactory.jpaProperty.hibernate.cache.keys_factory=eu.domibus.core.cache.DomibusCacheKeysFactory

# ---------------------------------- Security ----------------------------------

#Domibus encrypts the configured passwords if activated
#domibus.password.encryption.active=false

#Enable this property if the password encryption is activated. Add the list of configured passwords to be encrypted.
#domibus.password.encryption.properties=domibus.security.keystore.password,domibus.security.key.private.password,domibus.security.truststore.password,domibus.datasource.password,domibus.proxy.password,domibus.alert.sender.smtp.password,domibus.security.key.private.rsa.password,domibus.security.key.private.rsa.sign.password,domibus.security.key.private.rsa.decrypt.password,domibus.security.key.private.ecc.password,domibus.security.key.private.ecc.sign.password,domibus.security.key.private.ecc.decrypt.password

#The location where the encrypted key is stored
#domibus.password.encryption.key.location=${domibus.config.location}/internal/encrypt

#To activate security set this to false
#domibus.auth.unsecureLoginAllowed=true

#Number of console login attempt before the user is deactivated (default 5)
#domibus.console.login.maximum.attempt=5

#Time in seconds for a suspended user to be reactivated. (1 hour per default if property is not set, if 0 the user will not be reactivated)
#domibus.console.login.suspension.time=3600

#Cron job that determines the interval at which the system checks for account to be reactivated.
#domibus.account.unlock.cron=0 0/1 * * * ?

#When a certificate is about to expires the system will log a warning. The warning will appear as from the expiration date - the offset in days.
#domibus.certificate.revocation.offset=15

#Cron expression that specifies the frequency of the certificate revocation check.
#domibus.certificate.check.cron=0 0 0/1 * * ?

#The list of protocols to be excluded from CRL list (possible values: http, https, ftp, file, ldap, etc)
#domibus.certificate.crl.excludedProtocols=

#Configure http timeout (http.connection.timeout, http.socket.timeout, http.connection-manager.timeout) in seconds. Defaults to 10 seconds.
#domibus.certificate.crl.http.timeout=10

# ---------------------------------- Extensions ----------------------------------

#Name of the authentication extension used to verify the chain trust. Default is CXF
#domibus.extension.iam.authentication.identifier=DEFAULT_AUTHENTICATION_SPI
#Name of the authorization extension used to check incoming message authorization. Default is truststore check.
#domibus.extension.iam.authorization.identifier=DEFAULT_AUTHORIZATION_SPI

# ---------------------------------- Plugin Security ----------------------------------

#Number of plugin users login attempts before the user is deactivated (default 5)
#domibus.plugin.login.maximum.attempt=5

#Time in seconds for a suspended plugin user to be reactivated. (1 hour per default if property is not set, if 0 the user will not be reactivated)
#domibus.plugin.login.suspension.time=3600

#Cron job that determines the interval at which the system checks for plugin account to be reactivated.
#domibus.plugin.account.unlock.cron=0 0/1 * * * ?

# ---------------------------------- Password Policy -----------------------------------

#Password minimum complexity rules (empty to disable password complexity enforcement)
#domibus.passwordPolicy.pattern=^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[~`!@#$%^&+=\\-_<>.,?:;*/()|\\[\\]{}'"\\\\]).{16,32}$

#The error message shown to the user in case the password does not follow the regex put in the domibus.passwordPolicy.pattern property
#domibus.passwordPolicy.validationMessage=Minimum length: 16 characters;Maximum length: 32 characters;At least one letter in lowercase;At least one letter in uppercase;At least one digit;At least one special character

#Password expiration policy in days (0 to disable)
#domibus.passwordPolicy.expiration=90

#Default password expiration policy in days (0 to disable)
#domibus.passwordPolicy.defaultPasswordExpiration=15

#Password expiration policy: how many days before expiration should the system warn users at login
#domibus.passwordPolicy.warning.beforeExpiration=15

#Password reuse policy: do not reuse any of the last N passwords (0 to disable)
#domibus.passwordPolicy.dontReuseLast=5

#Default password validation policy enabled/disabled (by default is enabled)
#domibus.passwordPolicy.checkDefaultPassword=true

#Default user creation policy enabled/disabled (by default is enabled)
#domibus.passwordPolicy.defaultUser.create=true

#Default user password generation policy enabled/disabled (by default is enabled)
#domibus.passwordPolicy.defaultUser.autogeneratePassword=true

#Cron expression that specifies the frequency of the password expiration check
#domibus.passwordPolicies.check.cron=0 0 0/1 * * ?

# ---------------------------------- Plugin Users Password Policy -----------------------------------

#Password minimum complexity rules (empty to disable password complexity enforcement)
#domibus.plugin.passwordPolicy.pattern=(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[~`!@#$%^&+=\\-_<>.,?:;*/()|\\[\\]{}'"\\\\]).{16,32}$

#The error message shown to the user in case the password does not follow the regex put in the domibus.plugin.passwordPolicy.pattern property
#domibus.plugin.passwordPolicy.validationMessage=Minimum length: 16 characters;Maximum length: 32 characters;At least one letter in lowercase;At least one letter in uppercase;At least one digit;At least one special character

#Password expiration policy in days (0 to disable)
#domibus.plugin.passwordPolicy.expiration=90

#Default password expiration policy in days (0 to disable)
#domibus.plugin.passwordPolicy.defaultPasswordExpiration=1

#Password reuse policy: do not reuse any of the last N passwords (0 to disable)
#domibus.plugin.passwordPolicy.dontReuseLast=5

#Cron expression that specifies the frequency of the password expiration check
#domibus.plugin_passwordPolicies.check.cron=0 0 0/1 * * ?

# ---------------------------------- Payload -----------------------------------

#It is possible to configure Domibus to save the message payloads on the file system instead of the database. This setting is recommended when exchanging payloads bigger than 30MB.
#In order to enable the file system storage please configure the following property, it is the location on the file system where the payloads will be saved.
#Remark:
#In a cluster configuration the file system storage needs to be accessible by all the nodes from the cluster.
#domibus.attachment.storage.location=your_file_system_location

#Domibus encrypts the payloads stored in the database or file system if this property is active.
#domibus.payload.encryption.active=false

#Cron expression that specifies the frequency of checking if the temporary payloads have expired
#domibus.payload.temp.job.retention.cron=0 0/10 * * * ?

#The threshold in minutes for considering the temporary payloads as expired. The expired temporary payloads are scheduled to be deleted.
#domibus.payload.temp.job.retention.expiration=120

#Temporary files are excluded from deletion if this regular expression matches the file name
#domibus.payload.temp.job.retention.exclude.regex=.*ehcache-sizeof-agent.*

#List of directories to check for cleaning the temporary files.
#domibus.payload.temp.job.retention.directories=domibus.attachment.temp.storage.location

#Limit attachments per message to 28 (count enforced by Apache Santuario library for extended XML signature validation. Ref: https://santuario.apache.org/faq.html#faq-4.SecureValidation)
#domibus.payload.limit.28attachments.per.message=true

#When set to true, Domibus tries to decompress the archived payloads on receiving a message. In case it fails to decompress one payload, an error receipt is returned. Defaults to false.
#domibus.payload.decompression.validation.active=false

# ---------------------------------- Message -----------------------------------

#The suffix of the messageId generated by this instance of Domibus. Schema is:  ${UUID}@${SUFFIX}
#domibus.msh.messageid.suffix=domibus.eu

#The maximum size of message in bytes that can be downloaded via admin console
#domibus.message.download.maxSize=10000000

#Message resend job execution interval as a cron expression
#domibus.message.resend.cron = 0 0/1 * * * ?

#Activates the plugin notification of Test messages
#domibus.message.test.notification=false

# ---------------------------------- Retry -------------------------------------

#Retry Worker execution interval as a cron expression
#domibus.msh.retry.cron=0/30 * * * * ?

#Retry strategy grants few extra seconds to avoid not sending the last attempt (value in milliseconds, default 30000)
#domibus.msh.retry.messageExpirationDelay=30000

#Retry strategy adds these extra minutes to the interval used to search back for messages in WAITING_FOR_RETRY status. For performance reasons, the interval defaults to 10 minutes.
#When there are older messages in WAITING_FOR_RETRY (e.g. restored messages), increase the interval to capture those messages as well.
#domibus.msh.retry.timeoutDelay=10

#List of party names for which the smart retry feature is active (comma-separated list)
#domibus.smart.retry.enabled=

# ---------------------------------- Dynamic Discovery -------------------------

#Whether to use dynamic discovery or not
#domibus.dynamicdiscovery.useDynamicDiscovery=false

#The SML zone
#domibus.smlzone=acc.edelivery.tech.ec.europa.eu

#The dynamic discovery client to be used for the dynamic process. Possible values: OASIS and PEPPOL. Defaults to OASIS.
#domibus.dynamicdiscovery.client.specification=OASIS

#OASIS client specific properties

#Apart from validating response of signer certificates against the truststore, the Oasis Dynamic Discovery Client gives
#the possibility to add (optional) a regular expression to validate the subject of the SMP signer certificate when only issuer chain is added to truststore.
#domibus.dynamicdiscovery.oasisclient.regexCertificateSubjectValidation=^.*EHEALTH_SMP.*$

#The role of the responder PartyId for the Oasis Dynamic Discovery Client
#domibus.dynamicdiscovery.oasisclient.partyid.responder.role=http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/responder

#The type of the PartyId for the Oasis Dynamic Discovery Client
#domibus.dynamicdiscovery.oasisclient.partyid.type=urn:oasis:names:tc:ebcore:partyid-type:unregistered

#Peppol client specific properties

#Specifies the PEPPOL dynamic discovery client mode: PRODUCTION or TEST mode. Defaults to TEST.
#domibus.dynamicdiscovery.peppolclient.mode=TEST

#Apart from validating response of signer certificates against the truststore, the Peppol Dynamic Discovery Client gives
#the possibility to add (optional) a regular expression to validate the subject of the SMP signer certificate when only issuer chain is added to truststore,
#domibus.dynamicdiscovery.peppolclient.regexCertificateSubjectValidation=.*

#The role of the responder PartyId for the Peppol Dynamic Discovery Client
#domibus.dynamicdiscovery.peppolclient.partyid.responder.role=urn:fdc:peppol.eu:2017:roles:ap:as4

#The type of the PartyId for the Peppol Dynamic Discovery Client
#domibus.dynamicdiscovery.peppolclient.partyid.type=urn:fdc:peppol.eu:2017:identifiers:ap

# List of certificate policy OIDs separated by comma where at least one must be in the service metadata signer's
# certificate policy extension to consider it as is trusted. Example: 1.3.6.1.4.1.7879.13.25
# (empty value disables the certificate policy validation)
#domibus.dynamicdiscovery.client.allowedCertificatePolicyOIDs=

#The AS4 transport profile by which the endpoint is identified in the SMP response
#domibus.dynamicdiscovery.transportprofileas4=bdxr-transport-ebms3-as4-v1p0

#Retention cron expression for the job responsible for deleting from the truststore the dynamically discovered certificates and from the Pmode dynamically discovered parties
#It executes at 23:00 every Saturday
#domibus.dynamicdiscovery.lookup.clean.retention.cron=0 0 23 ? * SAT *

#Retention in hours for deleting the following entities:
# - from the truststore the dynamically discovered certificates
# - from the Pmode the dynamically discovered parties
# - final recipient endpoint URL
#Entities will be deleted if they are not lookup up during the configured value
#If the property value is empty, the entities will not be deleted
#domibus.dynamicdiscovery.lookup.clean.retention.hours=48

#Global cache property for dynamic discovery lookup caching in seconds
#domibus.dynamicdiscovery.lookup.cache.ttl=3600

# ---------------------------------- JMS ---------------------------------------

#Domibus internal queue used for dispatching the pull requests
#domibus.jms.queue.pull=domibus.internal.pull.queue

#The maximum pool size of the JMS connection factory
#domibus.jms.connectionFactory.maxPoolSize=100

#The maximum number of pending messages to be listed from the backend notification queue. Setting this property is expected to avoid timeouts due to huge result sets being served.
#Setting this property to zero returns all pending messages
#domibus.listPendingMessages.maxCount=10000

#The maximum number of messages to be listed from the JMS queues. Setting this property is expected to avoid timeouts due to huge results being served.
#Setting this property to zero returns all messages
#domibus.jms.queue.maxBrowseSize=10000

#Domibus internal queue used for alerts
#domibus.jms.queue.alert=domibus.internal.alert.queue

#Concurrency configured for executing internal commands
#domibus.jms.internal.command.concurrency=1-1

#The desired size for the JMS Session cache
#domibus.jms.connectionFactory.session.cache.size=1

# ---------------------------------- Validation --------------------------------

#If activated Domibus will verify before sending a message if the receiver's certificate is valid and not revoked. If the receiver's certificate
#is not valid or it has been revoked Domibus will not send the message and it will mark it as SEND_FAILURE (default is true)
#domibus.receiver.certificate.validation.onsending=true

#If activated Domibus will verify before sending a message if his own certificate is valid and not revoked. If the certificate is not valid
#or it has been revoked Domibus will not send the message and it will mark it as SEND_FAILURE (default is true)
#domibus.sender.certificate.validation.onsending=true

#If activated Domibus will verify before receiving a message if the sender's certificate is valid and not revoked. If the certificate is
#not valid or it has been revoked Domibus will not accept the message (default is true)
#domibus.sender.certificate.validation.onreceiving=true

#If activated Domibus will verify before receiving a message, the validity and authorization on the sender's certificate. When disabled,
#none of the other checks are performed on the sender's certificate.
#domibus.sender.trust.validation.onreceiving=true

#When this property is not empty Domibus will verify before receiving a message, that the subject of the sender's certificate matches the regular expression.
#domibus.sender.trust.validation.expression=

# List of certificate policy OIDs separated by comma. When this property is not empty Domibus will verify before receiving a message,
# that certificate contains at lest one certificate policy OID in certificatePolicy extension to consider it as is trusted.
#domibus.sender.trust.validation.allowedCertificatePolicyOIDs=

#When enabled, Domibus will verify before receiving a message, that the alias (party name) is present in the signing certificate subject.
#domibus.sender.certificate.subject.check=false

#When enabled, Domibus will verify before receiving a message, that the sender's certificate matches the certificate in the truststore,
#loaded based on the alias (party name)
#domibus.sender.trust.validation.truststore_alias=true

#When enabled, the system default certificates (cacerts) are used in addition to custom certificates, to validate that a call to a https server can be trusted
#domibus.cacerts.validation.enabled=true

#Accepted Format for MessageId (Default value, based on RFC2822 [CORE 5.2.2.1]: ^[\\x20-\\x7E]*$ )
#domibus.sendMessage.messageIdPattern=^[\\x20-\\x7E]*$

#Accepted Format for xsd:datetime for AS4 communication
#domibus.datetime.pattern.onreceiving=yyyy-MM-dd'T'HH:mm:ss[.SSSSSSSSS][.SSSSSS][.SSS][z]

#Format of xsd:datetime used for AS4Receipt
#domibus.datetime.pattern.onsending=yyyy-MM-dd'T'HH:mm:ss.SSS'Z'

#Validate PartyInfo From/To initiator and responder roles. This property helps maintaining backwards compatibility. It is recommended to be enabled. By default enabled.
#domibus.partyinfo.roles.validation.enabled=true

#Validate the qualified name of the Mpc in the received UserMessage on MSH endpoint matches the qualified name of the Mpc configured on the pMode leg configuration
#domibus.pmode.legconfiguration.mpc.validation.enabled=true

# ---------------------------------- Dispatcher --------------------------------

#Timeout values for communication between the Access Points
#ConnectionTimeOut - Specifies the amount of time, in milliseconds, that the consumer will attempt to establish a connection before it times out. 0 is infinite.
#domibus.dispatcher.connectionTimeout=60000

#ReceiveTimeout - Specifies the amount of time, in milliseconds, that the consumer will wait for a response before it times out. 0 is infinite.
#domibus.dispatcher.receiveTimeout=60000

#Allows chunking when sending messages to other Access Points
#domibus.dispatcher.allowChunking=false

#If domibus.dispatcher.allowChunking is true, this property sets the threshold at which messages start getting chunked(in bytes). Messages under this limit do not get chunked. Defaults to 100 MB.
#domibus.dispatcher.chunkingThreshold=104857600

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when sending messages to other Access Points
#domibus.dispatcher.concurency=5-20

#The timeout of the dispatcher JMS queue transaction(in seconds)
#domibus.dispatcher.timeout=300

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when sending large messages(SplitAndJoin) to other Access Points
#domibus.dispatcher.largeFiles.concurrency=1

#Cache the dispatcher clients used for communication between the Access Points. Defaults to true.
#domibus.dispatcher.cacheable=true

#Specifies if the connection will be kept alive between C2 and C3. Default value is true.
#domibus.dispatcher.connection.keepAlive=true

#Priority rules used to assign a specific JMS priority for dispatched messages. Multiple rules can be defined. Rules names must be unique in order to avoid name collision.
#More information about using priority rules can be found in the Admin Guide document.

#Priority rule name. The rule name will be further used to specify additional rule properties.
#domibus.dispatcher.priority.rule1=Priority rule description

#Service value to be matched against the sent message
#domibus.dispatcher.priority.rule1.service=ServiceValue

#List of actions separated by comma to be matched against the sent message
#domibus.dispatcher.priority.rule1.action=action1,action2,action3

#Priority value assigned to the JMS message. Accepted priority values must be between 1-9 included.
#domibus.dispatcher.priority.rule1.value=5

#(optional) Domibus creates a dedicated JMS listener for the rule in case this property is defined. More information can be found in the Admin Guide.
#domibus.dispatcher.priority.rule1.concurrency=5-10

# ---------------------------------- Task Executor -----------------------------

#Use the below property to customize the task executor threads count. Defaults to 100.
#domibus.taskExecutor.threadCount=100

#Use the below property to customize the msh endpoint task executor threads count. Defaults to 100.
#domibus.mshTaskExecutor.threadCount=100

# ---------------------------------- Retention ---------------------------------

#Cron expression used for configuring the retention worker scheduling. The retention worker deletes the expired messages(downloaded and not-downloaded).
#domibus.retentionWorker.cronExpression=0 0/1 * * * ?

#Uncomment the following line if you need to tweak the maximum downloaded messages to be deleted by the retention worker. Defaults to 50.
#domibus.retentionWorker.message.retention.downloaded.max.delete=50

#Uncomment the following line if you need to tweak the maximum not-downloaded messages to be deleted by the retention worker. Defaults to 50.
#domibus.retentionWorker.message.retention.not_downloaded.max.delete=50

#Uncomment the following line if you need to tweak the maximum sent messages to be deleted by the retention worker. Defaults to 50.
#domibus.retentionWorker.message.retention.sent.max.delete=50

#Uncomment the following line if you need to tweak the maximum messages with payload deleted to be fully deleted by the retention worker. Defaults to 50.
#domibus.retentionWorker.message.retention.payload_deleted.max.delete=50

#Define the deletion strategy. Possible values are: DEFAULT, PARTITIONS (Oracle only)
#domibus.retentionWorker.deletion.strategy=DEFAULT

### Configure next properties depending on the selected deletion strategy
### ---------------------------------- Retention - Deletion Strategy DEFAULT ---------------------------------

#Maximum number of messages to be deleted by the retention worker in a bulk delete (when not specified in the PMode MPC). Defaults to 1000, maximum allowed when using Oracle database.
#domibus.retentionWorker.message.retention.batch.delete=1000

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when deleting messages
#domibus.retention.jms.concurrency=5-10

### ---------------------------------- Retention - Deletion Strategy PARTITIONS ---------------------------------
#Cron expression used for configuring the partition worker scheduling. The partition worker verifies if partitions were properly created in advance
#domibus.partitions.worker.cron=0 9 * * * ?

#Number of days to check if partitions were successfully created in advance. Defaults to 7 days.
#domibus.partitions.creation.days_to_check=7

#When set to true, before dropping a partition, verifies if all messages on that partition were previously archived.
#This check is a guard rail for dropping partitions when the eArchiving mechanism is disabled. Default is true.
#domibus.partitions.drop.check.messages.earchived=true

#Cron expression used to configure the sanitizer worker that targets messages not in a final state that are not processed anymore
#domibus.ongoingMessagesSanitizing.worker.cron=0 0 0/2 ? * * *

# ---------------------------------- Proxy -------------------------------------
#domibus.proxy.enabled=false
#domibus.proxy.http.host=
#domibus.proxy.http.port=
#domibus.proxy.user=
#domibus.proxy.password=
#domibus.proxy.nonProxyHosts=

# ---------------------------------- ActiveMQ ----------------------------------

#The host of the JMS broker
#activeMQ.broker.host=localhost

#The name of the JMS broker
#activeMQ.brokerName=localhost

#The configuration file of the embedded ActiveMQ broker. In case an external broker is used this property is not needed and it should be removed
activeMQ.embedded.configurationFile=file:///${domibus.config.location}/internal/activemq.xml

#The service URL of the MBeanServer
#activeMQ.JMXURL=service:jmx:rmi:///jndi/rmi://${activeMQ.broker.host}:${activeMQ.connectorPort}/jmxrmi

#The port that the JMX connector will use for connecting to ActiveMQ
#activeMQ.connectorPort=1199

#The connection URI that the clients can use to connect to an ActiveMQ broker using a TCP socket
#activeMQ.transportConnector.uri=tcp://${activeMQ.broker.host}:61616

#The username that is allowed to connect to the ActiveMQ broker
#activeMQ.username=domibus

#THe password of the username defined in the activeMQ.username property
#activeMQ.password=changeit

#The persistence enabled flag
#activeMQ.persistent=true

#Sets the timeout before a close is considered complete
#activeMQ.connection.closeTimeout=15000

#Sets the connection response timeout
#activeMQ.connection.connectResponseTimeout=0

# ---------------------------------- Pulling-----------------------------------

#Cron expression used for configuring the message puller scheduling.
#domibus.msh.pull.cron=0 0 0/1 * * ?

# Number of threads used to parallelize the pull requests.
#domibus.pull.queue.concurency=1-1

# Number of threads used to parallelize the pull receipts.
#domibus.pull.receipt.queue.concurrency=5-20

#Number or requests per MPC executed every cron cycle. Generic value that applies to all MPCs.
#domibus.pull.request.send.per.job.cycle=1

#Optional number or requests per specific MPC executed every cron cycle.
#Takes precedence over the generic "domibus.pull.request.send.per.job.cycle property" value.
#MPCs are indicated by their short names.
#domibus.pull.request.send.per.job.cycle.per.mpc.MPC_NAME=1

#Time in second for the system to recover its full pull capacity when job schedule is one execution per second.
#If configured to 0, no incremental frequency is executed and the pull pace is executed at its maximum.
#domibus.pull.request.frequency.recovery.time=0

#Number of connection failure before the system decrease the pull pace.
#domibus.pull.request.frequency.error.count=10

#Pull Retry Worker execution interval as a cron expression
#domibus.pull.retry.cron=0/10 * * * * ?

#Allow dynamic initiator on pull requests - 0 or multiple initiators are allowed in the Pmode process
#domibus.pull.dynamic.initiator=false

#Allow multiple legs configured on the same pull process (with the same security policy)
#domibus.pull.multiple_legs=false

#Force message into READY_TO_PULL when mpc attribute is present (default is false)
#domibus.pull.force_by_mpc=false

#MPC initiator separator. This is used when the MPC provides information on the initiator: baseMpc/SEPARATOR/partyName
#domibus.pull.mpc_initiator_separator=PID

# ---------------------------------- Alert management -----------------------------------
#Enable/disable the entire alert module. Pay attention to the fact that if the module is activated, all properties
#under the mandatory section should be configured.
#domibus.alert.active=true

#Allow to disable alert mail sending.
#domibus.alert.mail.sending.active=false

#SMTP Socket I/O timeout value in milliseconds
#domibus.alert.mail.smtp.timeout=5000

# -----------------------------------Mandatory configuration start (if domibus.alert.active=true and domibus.alert.mail.sending.active=true) -----------

#SMTP server url for sending alert.
#domibus.alert.sender.smtp.url=

#SMTP server port.
#domibus.alert.sender.smtp.port=

#(optional) Smtp server user.
#domibus.alert.sender.smtp.user=

#(optional) Smtp server user password.
#domibus.alert.sender.smtp.password=

#Alert sender email.
#domibus.alert.sender.email=

#Alert email receiver. You can specify multiple recipients by using semicolon separated email addresses:name1@gmail.com;name2@gmail.com
#domibus.alert.receiver.email=

# ----------------------------------Mandatory configuration end-----------------------------------

#The following properties can stay commented if no modifications to the default values are needed.

#Cron configuration for cleaning alerts.
#domibus.alert.cleaner.cron=0 0 0/1 * * ?

#Lifetime in days of alerts before cleaning.
#domibus.alert.cleaner.alert.lifetime=20

#Concurrency to process the alerts.
#domibus.alert.queue.concurrency=1

#Frequency of failed alerts retry.
#domibus.alert.retry.cron=0 0/10 * * * ?

#Elapsed time in minutes between alert retry.
#domibus.alert.retry.time=10

#Maximum number of attempts for failed alerts
#domibus.alert.retry.max_attempts=2

# ---------------------------------- Alert management:messaging module -----------------

#Enable/disable the messaging alert module.
#domibus.alert.msg.communication_failure.active=true

#Message status change that should be notified by the messaging alert module. Comma separated.
#domibus.alert.msg.communication_failure.states=SEND_FAILURE

#Alert levels corresponding to message status defined in previous property(domibus.alert.msg.communication_failure.states) .
#Should be (HIGH, MEDIUM OR LOW)
#domibus.alert.msg.communication_failure.level=HIGH

#Messaging alert module mail subject.
#domibus.alert.msg.communication_failure.mail.subject=Message status change

#The priority level of the alerts that report the messages in a non-final state that are not processed anymore (LOW, MEDIUM or HIGH)
#domibus.ongoingMessagesSanitizing.alert.level=MEDIUM

#Subject of the email alerts that report the messages in a non-final state that are not processed anymore
#domibus.ongoingMessagesSanitizing.alert.email.subject=Ongoing messages

#Body of the email alerts that report the messages in a non-final state that are not processed anymore
#domibus.ongoingMessagesSanitizing.alert.email.body=There are messages currently in ongoing statuses that are not processed anymore. Here is the list of IDs and statuses of these messages: [{messages}].

# ---------------------------------- Alert management:Authentication module -----------------

#Enable/disable the login failure alert of the authentication module.
#domibus.alert.user.login_failure.active=true

#Alert level for login failure.
#domibus.alert.user.login_failure.level=LOW

#Login failure mail subject.
#domibus.alert.user.login_failure.mail.subject=Login failure

#Enable/disable the account disable alert of the authentication module.
#domibus.alert.user.account_disabled.active=true

#Alert level for account disabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
#domibus.alert.user.account_disabled.level=HIGH

#When should the account disabled alert be triggered.
# 2 possible values:
# AT_LOGON: An alert will be triggered each time a user tries to login to a disabled account.
# WHEN_BLOCKED: An alert will be triggered once when the account got disabled.
#domibus.alert.user.account_disabled.moment=WHEN_BLOCKED

#Account disabled mail subject.
#domibus.alert.user.account_disabled.subject=Account disabled

#Enable/disable the account enabled alert of the authentication module.
#domibus.alert.user.account_enabled.active=false

#Alert level for account enabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
#domibus.alert.user.account_enabled.level=MEDIUM

#Account enabled mail subject.
#domibus.alert.user.account_enabled.subject=Account enabled

# ---------------------------------- Alert management:Certificate scanner -----------------

#Enable/disable the imminent certificate expiration alert of certificate scanner module.
#domibus.alert.cert.imminent_expiration.active=true

#Number of days before revocation as from when the system should start sending alerts.
#domibus.alert.cert.imminent_expiration.delay_days=60

#Frequency in days between alerts.
#domibus.alert.cert.imminent_expiration.frequency_days=14

#Certificate imminent expiration alert level.
#domibus.alert.cert.imminent_expiration.level=HIGH

#Certificate imminent expiration mail subject.
#domibus.alert.cert.imminent_expiration.mail.subject=Certificate imminent expiration

#Enable/disable the certificate expired alert of certificate scanner module.
#domibus.alert.cert.expired.active=true

#Frequency in days between alerts.
#domibus.alert.cert.expired.frequency_days=7

#How long(in days) after the revocation should the system trigger alert for the expired certificate.
#domibus.alert.cert.expired.duration_days=90

#Certificate expired alert level.
#domibus.alert.cert.expired.level=HIGH

#Certificate expired mail subject.
#domibus.alert.cert.expired.mail.subject=Certificate expired

# ---------------------------------- Alert management:Password policy  -----------------

#Enable/disable the imminent password expiration alert
#domibus.alert.password.imminent_expiration.active=true

#Number of days before expiration as for how long before expiration the system should send alerts.
#domibus.alert.password.imminent_expiration.delay_days=15

#Frequency in days between alerts.
#domibus.alert.password.imminent_expiration.frequency_days=3

#Password imminent expiration alert level.
#domibus.alert.password.imminent_expiration.level=LOW

#Password imminent expiration mail subject.
#domibus.alert.password.imminent_expiration.mail.subject=Password imminent expiration

#Enable/disable the imminent password expiration alert
#domibus.alert.password.expired.active=true

#Number of days after expiration as for how long the system should send alerts.
#domibus.alert.password.expired.delay_days=30

#Frequency in days between alerts.
#domibus.alert.password.expired.frequency_days=5

#Password expiration alert level.
#domibus.alert.password.expired.level=LOW

#Password expiration mail subject.
#domibus.alert.password.expired.mail.subject=Password expired

# ---------------------------------- Alert management: Plugin Password policy  -----------------

#Enable/disable the imminent password expiration alert
#domibus.alert.plugin_password.imminent_expiration.active=true

#Number of days before expiration as for how long before expiration the system should send alerts.
#domibus.alert.plugin_password.imminent_expiration.delay_days=15

#Frequency in days between alerts.
#domibus.alert.plugin_password.imminent_expiration.frequency_days=3

#Password imminent expiration alert level.
#domibus.alert.plugin_password.imminent_expiration.level=LOW

#Password imminent expiration mail subject.
#domibus.alert.plugin_password.imminent_expiration.mail.subject=Password imminent expiration

#Enable/disable the imminent password expiration alert
#domibus.alert.plugin_password.expired.active=true

#Number of days after expiration as for how long the system should send alerts.
#domibus.alert.plugin_password.expired.delay_days=30

#Frequency in days between alerts.
#domibus.alert.plugin_password.expired.frequency_days=5

#Password expiration alert level.
#domibus.alert.plugin_password.expired.level=LOW

#Password expiration mail subject.
#domibus.alert.plugin_password.expired.mail.subject=Password expired

# ---------------------------------- Alert management:Authentication module for Plugin users-----------------

#Enable/disable the login failure alert of the authentication module.
#domibus.alert.plugin.user.login_failure.active=true

#Alert level for login failure.
#domibus.alert.plugin.user.login_failure.level=LOW

#Login failure mail subject.
#domibus.alert.plugin.user.login_failure.mail.subject=Login failure

#Enable/disable the account disable alert of the authentication module.
#domibus.alert.plugin.user.account_disabled.active=true

#Alert level for account disabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
#domibus.alert.plugin.user.account_disabled.level=HIGH

#When should the account disabled alert be triggered.
# 2 possible values:
# AT_LOGON: An alert will be triggered each time a user tries to login to a disabled account.
# WHEN_BLOCKED: An alert will be triggered once when the account got disabled.
#domibus.alert.plugin.user.account_disabled.moment=WHEN_BLOCKED

#Account disabled mail subject.
#domibus.alert.plugin.user.account_disabled.subject=Account disabled

#Enable/disable the account enabled alert of the authentication module.
#domibus.alert.plugin.user.account_enabled.active=false

#Alert level for account enabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
#domibus.alert.plugin.user.account_enabled.level=MEDIUM

#Account enabled mail subject.
#domibus.alert.plugin.user.account_enabled.subject=Account enabled

# ---------------------------------- Alert management: Partitions -----------------
#Frequency in days between alerts.
#domibus.alert.partition.check.frequency_days=1

# ---------------------------------- Alert management: E-Archiving Module -----------------
#Enable/disable the EArchiving notification failed alerts.
#domibus.alert.earchive.notification.active=true

#EArchiving notification failed alert level.
#domibus.alert.earchive.notification.level=MEDIUM

#EArchiving notification failed mail subject.
#domibus.alert.earchive.notification.mail.subject=E-Archiving client notification failed

# ---------------------------------- Alert management: Connection Monitoring -----------------
#Enable/disable the Connection monitoring failed notification alerts.
#domibus.alert.connection.monitoring.parties=ALL

#Connection monitoring failed alert frequency in days.
#domibus.alert.connection.monitoring.frequency_days=1

#EArchiving notification failed alert level.
#domibus.alert.connection.monitoring.level=MEDIUM

#EArchiving notification failed mail subject.
#domibus.alert.connection.monitoring.mail.subject=Connection monitoring failed

# ---------------------------------- Various -----------------------------------

#The factory for creating SOAPMessage objects
#messageFactoryClass=com.sun.xml.messaging.saaj.soap.ver1_2.SOAPMessageFactory1_2Impl

#If disabled, Domibus will not notify the plugins when the state of the User Message changes. Defaults to true.
#domibus.plugin.notification.active=true

#If disabled, Domibus will not save the non repudiation audit data. Defaults to true.
#domibus.nonrepudiation.audit.active=true

#The list of mime-types that will not be compressed (in outgoing messages) even if compression is turned on for the given message.
#compressionBlacklist=application/vnd.etsi.asic-s+zip,image/jpeg

#Whether to delete the message payload on send failure. Defaults to false (the administrator can put the message back in the send queue).
#domibus.sendMessage.failure.delete.payload=false

#Whether to delete the message payload on send success. Defaults to true (preserves backwards compatibility).
#domibus.sendMessage.success.delete.payload=true

#If disabled, Domibus will not save the message attempt details when there is a failure sending a message. Defaults to true.
#domibus.sendMessage.attempt.audit.active=true

#Should unrecoverable errors be retried or not
#domibus.dispatch.ebms.error.unrecoverable.retry=true

#Number of threads used to parallelize the dispatching of messages to the plugins.
#domibus.internal.queue.concurency=3-10

#characters that are not accepted in user input
#domibus.userInput.blackList='\u0022(){}[];,+=%&*#<>/\\

#characters that are accepted in user input
#domibus.userInput.whiteList=

#The maximum length accepted for a property value, in bytes. Defaults to 10000.
#domibus.property.length.max=10000

#Enables the validation of Domibus properties values (defaults to true)
#domibus.property.validation.enabled=true

#The minimum interval of time after which a new backup file is created, in hours. Defaults to 24. 0 for creating a backup file on every change.
#domibus.property.backup.period.min=24

#The maximum number of backup files to keep. Defaults to 10. 0 for keeping all of them.
#domibus.property.backup.history.max=10

#Prints the AS4 payload in the logs while org.apache.cxf is set to at least INFO in logback.xml. Defaults to false.
#domibus.logging.payload.print=false

#Prints the AS4 metadata in the logs when org.apache.cxf is set to at least INFO in logback.xml. Defaults to true.
#domibus.logging.metadata.print=true

#prints the raw XML response in the logs in case of EBMS3 error on receiver/sender side (if eu.domibus is put at least on ERROR)
#domibus.logging.ebms3.error.print=true

#The size limit at which messages are truncated in the logs when org.apache.cxf is set to at least INFO in logback.xml
# Number between 0 and 1000000000 bytes
# Defaults to limit (18000 bytes)
#domibus.logging.cxf.limit=18000

#Prints the details of the remote receiver certificate used to encrypt the message when sending or the details of the
#remote sender certificate used to verify the trust of the message when receiving. Defaults to false.
#domibus.logging.remote.certificates.print=false

#Prints the details of the local sender certificate corresponding to its private key being used to sign the message
#when sending or the details of the local receiver certificate corresponding to its private key when decrypting the
#message when receiving. Please note, when enabling this property, there is an extra delay introduced needed to load
#the certificate corresponding to the private key. Defaults to false.
#domibus.logging.local.certificates.print=false

#Disables offloading the SSL connection to another application - e.g. SSL Forward Proxy - (defaults to false)
#domibus.connection.cxf.ssl.offload.enable=false

#The maximum file size in bytes that can be uploaded through REST ( pMode, trustStore). The default is 50MB.
#domibus.file.upload.maxSize=52428800

#How long(in seconds) HSTS should last in the browser's cache(default one year)
#domibus.httpSecurity.httpStrictTransportSecurity.maxAge=31536000

# ------------------------------- Domibus instance/environment name ------------------

#domibus.instance.name = Domibus

# ---------------------------------- Metrics -----------------

#Enable jmx reporter for dropwizard metrics. The following warning:
#We do not recommend that you try to gather metrics from your production environment.JMX's RPC API is fragile.
#For development purposes and browsing, though, it can be very useful.
#domibus.metrics.jmx.reporter.enable=false

#Enable SLF4J reporter for dropwizard metrics.
#domibus.metrics.slf4j.reporter.enable=false

#The time unit used to configure the frequency of writing statistics into the statistic.log file.
#Possible values are:SECONDS, MINUTES, HOURS
#domibus.metrics.slf4j.reporter.period.time.unit=MINUTES

#The number of period of the previously time unit used to configure the frequency of writing statistics into the statistic.log file.
#For example, the default configuration will write statistics with the file every 1 MINUTE.
#domibus.metrics.slf4j.reporter.period.number=1

#Activate drop wizard memory metrics
#domibus.metrics.monitor.memory=false

#Activate drop wizard gc metrics
#domibus.metrics.monitor.gc=false

#Activate drop wizard cached threads metrics
#domibus.metrics.monitor.cached.threads=false

#Activate drop wizard JMS Queues metrics
#domibus.metrics.monitor.jms.queues=false

# how long (in seconds) the JMS count will be cached
# defaults to 10
#domibus.metrics.monitor.jms.queues.refresh.period=10

# show counts only for DLQ queue
#domibus.metrics.monitor.jms.queues.show.dlq.only=true

# ------------------------------- SplitAndJoin ---------------------------------------

#SplitAndJoin only: Domibus uses a  file system location for storing temporary data when processing SplitAndJoin messages
#In a cluster configuration the temporary file system storage needs to be accessible by all the nodes from the cluster.
#domibus.attachment.temp.storage.location=your_temporary_file_system_location

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when sending the SourceMessage receipt(Split and Join) to other Access Points
#domibus.dispatcher.splitAndJoin.concurrency=1

#The threshold value in MB to switch from synchronous to asynchronous saving of outgoing SourceMessage payloads
#domibus.dispatcher.splitAndJoin.payloads.schedule.threshold=1000

#Cron expression that specifies the frequency of the checking if the joinInterval has expired
#domibus.splitAndJoin.receive.expiration.cron=0 0/5 * * * ?

# --------------------------- Connection Monitoring ----------------------------------

#Specifies the parties for which to monitor the connection (comma-separated list)
#domibus.monitoring.connection.party.enabled=

#Specifies the parties for which to delete the old test messages (comma separated list)
#domibus.monitoring.connection.party.history.delete=ALL

#Cron expression that specifies the frequency of test messages sent to monitor the C2-C3 connections
#domibus.monitoring.connection.cron=0 0 0/2 ? * * *

#Cron expression that specifies the frequency of test messages sent to itself (e.g. C2-C2 connections)
#domibus.monitoring.connection.self.cron=0 0 0/1 ? * * *

#Cron expression that specifies the frequency of deleting test message history sent to gateway party
#domibus.monitoring.connection.messages.received.history.delete.cron=0 0 0/1 ? * * *

# --------------------------------------------Error Logs-------------------------------

#Cron configuration for cleaning error logs without message ids.
#domibus.errorlog.cleaner.cron=0 0 0/1 * * ?

#Cron job will delete error logs without message ids older than this property days
#domibus.errorlog.cleaner.older.days=100

#how maximum error logs will be deleted for each job run
#domibus.errorlog.cleaner.batch.size=5000

# --------------------------------------------EArchiving-------------------------------
#Domibus allows for e-archiving if activated
#domibus.earchive.active=false

#In a cluster configuration the earchive file system storage needs to be accessible by all the nodes from the cluster.
#domibus.earchive.storage.location=your_file_system_location

#Allows to create empty export batches if no messages are found. If false, no batch nor files created when no messages found.
#domibus.earchive.export.empty=false

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#for the eArchiving queue
#domibus.earchive.queue.concurrency=1-1

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when notify batches updates to other EArchive client
#domibus.earchive.notification.queue.concurrency=1-1

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when error in notifying batches updates to other EArchive client
#domibus.earchive.notification.dlq.concurrency=1-1

#Cron configuration for executing the eArchiving continuous process.
#domibus.earchive.cron=0 0 0/1 * * ?

#Cron configuration for executing the eArchiving sanity process.
#domibus.earchive.sanitizer.cron=0 0 0/1 * * ?

#The creation date of the last UserMessage processed by the earchiving continuous batch minus the ['messageCheck.delay' hour] will be latest userMessage taken for the sanitizer
#domibus.earchive.sanitizer.messagesCheck.delay.hours=24

#Cron configuration for executing the eArchiving cleanup process.
#domibus.earchive.retention.cron=0 0 0/2 * * ?

#maximum messages to be archived for one batch
#domibus.earchive.batch.size=5000

#maximum payload size of messages to be archived for one batch(in Mb); 0 to disable
#domibus.earchive.batch.size.payload=0

#maximum earchive batches to be created during one job
#domibus.earchive.batch.max=10

#Timeout used to retrieve the messages in minutes. Defaults to 0.
# WARNING: this value is rounded to the previous whole hour to limit the messages search scope
# (ex: runtime = 15h12 | if retry.timeout=5  -> latest time for a message to be taken into account: 15h00 and earlier
#                      | if retry.timeout=30 -> latest time for a message to be taken into account: 14h00 and earlier)
#-1 disables this functionality and retrieve the timeout with the loaded PMode
#domibus.earchive.batch.retry.timeout=0

#Endpoint where the e-archiving client receives notifications
#domibus.earchive.notification.url=

#The user used to access the endpoint of the e-archiving client
#domibus.earchive.notification.username=

#The password used to access the endpoint of the e-archiving client
#domibus.earchive.notification.password=

#Timeout used when notifying the e-archiving client
#domibus.earchive.notification.timeout=5000

#Specify whether to use a proxy when notifying the e-archiving client
#domibus.earchive.notification.useProxy=false

# For methods: History Of Exports and enqueued batches, also return message list as part of batches objects.
# Note: in case of large batch size returning message list in all of the batches in a list will slow down the response time of the services.
#domibus.earchive.rest.messages.return=false

#If a batch is not archived during this time, it is considered as expired
#domibus.earchive.retention.days=30

#Maximum number of earchive batches to delete at a time
#domibus.earchive.retention.delete.max=5000

#If physically delete archived and/or expired batches from the corresponding tables
#domibus.earchive.retention.delete.db=true

#An alert is sent if the start date of the continuous job was not updated between now and now - allowed_window (in hours)
#domibus.earchive.start_date.stopped.allowed_hours=24

#Enable/disable the Earchive non final message alert.
#domibus.alert.earchive.messages_non_final.active=true

#Alert level for Earchive non final message.
#domibus.alert.earchive.messages_non_final.level=HIGH

#Earchive non final message mail subject.
#domibus.alert.earchive.messages_non_final.mail.subject=Earchive: message not in final state

#Enable/disable the Earchive start date stopped alert.
#domibus.alert.earchive.start_date_stopped.active=true

#Alert level for Earchive start date stopped.
#domibus.alert.earchive.start_date_stopped.level=HIGH

#Earchive start date stopped mail subject.
#domibus.alert.earchive.start_date_stopped.mail.subject=Earchive: continuous job start date stopped

#Enable if e-archiving client needs to receive notifications with additional details like message start date and end date
#domibus.earchive.notification.details.enabled=false

#Enable/disable the Earchive message export failed alert.
#domibus.alert.earchive.export.failed.active=true

#Alert level for Earchive message export failed alert.
#domibus.alert.earchive.export.failed.level=HIGH

#Earchive message export failed alert mail subject.
#domibus.alert.earchive.export.failed.mail.subject=Earchive: sanitizer export message failed

# --------------------------------------------Quartz-------------------------------
#Specifies the amount of time, in milliseconds that used to check if any quartz triggers are blocked. Default value is 10 minutes.
#domibus.quartz.trigger.blocked.duration=600000

# --------------------------------------------Distributed Cache -------------------------------
#The distributed cache is only used when Domibus runs in a cluster eg domibus.deployment.clustered=true

#Maximum used heap size in megabytes
#domibus.cache.distributed.size=5

#The maximum number of seconds for each entry to stay in the cache. Entries that are older than timeToLiveSeconds will be automatically evicted from the cache.
#Updates on the entry will change the eviction time. Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 1h.
#domibus.cache.distributed.ttl=3600

#Maximum number of seconds for each entry to stay idle in the cache. Entries that are idle (not touched) for more than max idle seconds will get automatically evicted from the cache.
#Entry is touched if get(), getAll(), put() or containsKey() is called. Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 3600.
#The time precision is limited by 1 second. The MaxIdle that less than 1 second can lead to unexpected behaviour.
#domibus.cache.distributed.idle.max=3600

#The near cache default size for the distributed cache
#domibus.cache.distributed.nearcache.size=5000

#The maximum number of seconds for each entry to stay in the near cache
#domibus.cache.distributed.nearcache.ttl=3600

#Set the maximum number of seconds each entry can stay in the Near Cache as untouched (not-read).
#Entries that are not read (touched) more than domibus.cache.distributed.nearcache.idle.max value will get removed from the Near Cache.
#domibus.cache.distributed.nearcache.idle.max=3600

#Sets the port the distributed cache member will try to bind on.
#A valid port value is between 0 and 65535. A port number of 0 will let the system pick up an ephemeral port.
#domibus.cache.distributed.port=6701

#Sets if a distributed cache member is allowed to find a free port by incrementing the port number when it encounters an occupied port.
#If you explicitly want to control the port a distributed cache member is going to use, set domibus.cache.distributed.port.autoincrement to false. In this case, the distributed cache member is going to try the port
#and if the port is not free, the member will not start and throw an exception.
#If this value is set to true, the distributed cache will start at the port specified and will try until it finds a free port, or until it runs out of ports to try
#domibus.cache.distributed.port.autoincrement=true

#The maximum number of ports allowed to use in case autoincrement is set to true
#domibus.cache.distributed.port.count=5

#Sets the well known members of the distributed cache. Can be a comma separated string, eg '10.11.12.1,10.11.12.2' which indicates multiple members are going to be added.
#You can also provide a range of IP addresses, such as 10.11.12.1-7.
#domibus.cache.distributed.members=127.0.0.1

